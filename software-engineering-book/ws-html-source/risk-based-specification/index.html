
<!DOCTYPE html>
<html lang="en-GB"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Web section – Software Engineering 10th edition</title><link rel="dns-prefetch" href="//s0.wp.com"><link rel="dns-prefetch" href="//secure.gravatar.com"><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//s.w.org"><link rel="stylesheet" id="wp-block-library-css" href="https://c0.wp.com/c/5.2.4/wp-includes/css/dist/block-library/style.min.css" type="text/css" media="all"><link rel="stylesheet" id="chld_thm_cfg_parent-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/style.css" type="text/css" media="all"><link rel="stylesheet" id="freedom_style-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom-child1/style.css" type="text/css" media="all"><link rel="stylesheet" id="freedom_googlefonts-css" href="http://fonts.googleapis.com/css?family=Fira+Sans%7CVollkorn&ver=5.2.4" type="text/css" media="all"><link rel="stylesheet" id="freedom-fontawesome-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/fontawesome/css/font-awesome.css" type="text/css" media="all"><link rel="stylesheet" id="easy_table_style-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/plugins/easy-table/themes/default/style.css" type="text/css" media="all"><link rel="stylesheet" id="chld_thm_cfg_separate-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom-child1/ctc-style.css" type="text/css" media="all"><link rel="stylesheet" id="jetpack_css-css" href="https://c0.wp.com/p/jetpack/7.8/css/jetpack.css" type="text/css" media="all"><script type="text/javascript" src="https://c0.wp.com/c/5.2.4/wp-includes/js/jquery/jquery.js"></script><script type="text/javascript" src="https://c0.wp.com/c/5.2.4/wp-includes/js/jquery/jquery-migrate.min.js"></script><script type="text/javascript" src="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/js/freedom-custom.js"></script><link rel="dns-prefetch" href="//v0.wordpress.com"><link rel="dns-prefetch" href="//c0.wp.com"><style type="text/css">img#wpstats{display:none}</style><style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style><style type="text/css">
				/* If html does not have either class, do not show lazy loaded images. */
				html:not( .jetpack-lazy-images-js-enabled ):not( .js ) .jetpack-lazy-image {
					display: none;
				}
			</style><script>
				document.documentElement.classList.add(
					'jetpack-lazy-images-js-enabled'
				);
			</script><meta property="og:type" content="article"><meta property="og:title" content="Event-driven control"><meta property="og:url" content="https://iansommerville.com/software-engineering-book/static/web/archpatterns/event-driven-control/"><meta property="og:description" content="In centralized control models, control decisions are usually determined by the values of some system state variables. By contrast, event-driven control models are driven by externally generated eve…"><meta property="article:published_time" content="2014-10-07T13:01:04+00:00"><meta property="article:modified_time" content="2019-02-07T09:11:52+00:00"><meta property="og:site_name" content="Software Engineering 10th edition"><meta property="og:image" content="https://s0.wp.com/i/blank.jpg"><meta property="og:locale" content="en_GB"><meta name="twitter:text:title" content="Event-driven control"><meta name="twitter:card" content="summary"><style type="text/css" id="wp-custom-css">
				img.myimg {
	display: block;
  margin-left: auto;
  margin-right: auto; 
	margin-top: 35px;
	padding: 5px;
	border-style: solid;
	border-width: 1px;
	border-color: black;
}
img.horiz {
	width: 680px;
}

img.vert {
	height: 680px;
}

figcaption.mycap {
  margin-left: 150px;
  margin-right: 150px; 
	font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif; 
	font-size: 19px;
	color: #808080;   /* Mid grey */
	font-weight: normal;
	text-align: center;
	margin-top: 20px;
	margin-bottom: 40px;
	padding-bottom: 10px;
	border-bottom: 1px solid #000000;  /* black */
}

figcaption.noborder {
	margin-bottom: 0px;
	border-bottom: 0px solid #000000;  /* black */
}

figcaption.nospace{
	margin-top: 0px
}

figcaption.para {
	text-align:justify;
}			</style></head><body class="page-template-default page page-id-697 page-child parent-pageid-282 no-sidebar-full-width wide">
<div id="page" class="hfeed site">
		<header id="masthead" class="site-header clearfix"><div id="header-text-nav-container" class="clearfix">
			<div class="inner-wrap">
				<div id="header-text-nav-wrap" class="clearfix">
					<div id="header-left-section">
												<div id="header-text" class="">
															<h3 id="site-title">
									<a href="https://iansommerville.com/software-engineering-book/static/" title="Software Engineering 10th edition" rel="home">Software Engineering 10th edition</a>
								</h3>
															<p id="site-description">Web sections</p>
													</div>
					</div>
			</div>

	</div>

		
	</header><div id="main" class="clearfix">
		<div class="inner-wrap clearfix">


	<div id="primary">
		<div id="content" class="clearfix">
			

<article id="post-333" class="post-333 page type-page status-publish hentry"><header class="entry-header"><h1 class="entry-title">
				Risk-based specification			</h1>
			</header><div class="entry-content clearfix">
		<p>Dependability and security requirements can be thought of as protection requirements. These specify how a system should protect itself from internal faults, stop system failures causing damage to its environment, stop accidents or attacks from the system’s environment damaging the system and facilitate recovery in the event of failure. To discover these protection requirements, you need to understand the risks to the system and its environment. A risk-driven approach to requirements specification takes into account the dangerous events that may occur, the probability that these will actually occur, the probability that damage will result from such an event and the extent of the damage caused. Security and dependability requirements can then be established, based on an analysis of possible causes of dangerous events.</p>
<p>Risk-driven specification is an approach that has been widely used by safety and security-critical systems developers. It focuses on those events that could cause the most damage or that are likely to occur frequently. Events that have only minor consequences or that are extremely rare may be ignored. In safety-critical systems, the risks are associated with hazards that can result in accidents; in security-critical systems, the risks come from insider and outsider attacks on a system that are intended to exploit possible vulnerabilities.</p>
<p>A general risk-driven specification process (Figure 1) involves understanding the risks faced by the system, discovering their root causes and generating requirements to manage these risks.</p>
<figure><
<img class="myimg horiz" src="https://www.dropbox.com/s/1yj00hw1eopjqix/12-Risk-driven-Spec.jpg?raw=1" alt="Image">
<figcaption class="mycap">
Figure 1. Risk-driven specification processes<br></figcaption></figure>
<p>The stages in this risk-driven specification process are:</p>
<ol><li><em>Risk identification</em> Potential risks to the system are identified. These are dependent on the environment in which the system is to be used. Risks may arise from interactions between the system and rare conditions in its operating environment. The Warsaw accident that I discussed earlier happened when crosswinds generated during a thunderstorm caused the plane to tilt so that (unusually) it landed on one wheel rather than two wheels.</li>
<li><em>Risk analysis and classification </em>Each risk is considered separately. Those that are potentially serious and not implausible are selected for further analysis. At this stage, risks may be eliminated because they are unlikely to arise or because they cannot be detected by the software (e.g. an allergic reaction to the sensor in the insulin pump system).</li>
<li><em>Risk decomposition</em> Each risk is analyzed to discover potential root causes of that risk. Root causes are the reasons why a system may fail. They may be software or hardware errors or inherent vulnerabilities that result from system design decisions.</li>
<li><em>Risk reduction </em>Proposals for ways in which the identified risks may be reduced or eliminated are made. These contribute to the system dependability requirements that define the defenses against the risk and how the risk will be managed.</li>
</ol><p>For large systems, risk analysis may be structured into phases, (Leveson, 1995) where each phase considers different types of risk:</p>
<ol><li><em>Preliminary risk analysis</em>, where major risks from the system’s environment are identified. These are independent from the technology used for system development. The aim of preliminary risk analysis is to develop an initial set of security and dependability requirements for the system.</li>
<li><em>Life cycle risk analysis</em>, which takes place during system development and which is mostly concerned with risks that arise from system design decisions. Different technologies and system architectures have their own associated risks. At this stage, you should extend the requirements to protect against these risks.</li>
<li><em>Operational risk analysis</em>, which is concerned with the system user interface and risks from operator errors. Again, once decisions have been made on the user interface design, further protection requirements may have to be added.</li>
</ol><p>These phases are necessary because it is impossible to make all dependability and security decisions without complete information about the system implementation. Security and dependability requirements are particularly affected by technology choices and design decisions. System checks may have to be included to ensure that third-party components have operated correctly. Security requirements may have to be modified because they conflict with the security features that are provided by an off-the-shelf system.</p>
<p>For example, a security requirement may be that users should identify themselves to a system using a pass phrase rather than a password. Pass phrases are considered to be more secure than passwords. They are harder for an attacker to guess or to discover using an automated password cracking system. However, if a decision is made to use an existing system that only supports password-based authentication, then this security requirement cannot be supported. It may then be necessary to include additional functionality in the system to compensate for the increased risks of using passwords rather than pass phrases.</p>
			</div>

	</article>
	
				<footer id="colophon" class="clearfix"><div class="footer-socket-wrapper clearfix">
				<div class="inner-wrap">
					<div class="footer-socket-area">
						<div class="copyright">Copyright © 2019&nbsp<a href="https://iansommerville.com/software-engineering-book/static/" title="Software Engineering 10th edition"><span>Software Engineering 10th edition</span></a>. </div>					</div>
				</div>
			</div>
		</footer><a href="#masthead" id="scroll-up"><i class="fa fa-chevron-up"></i></a>
	</div>
		<div style="display:none">
	</div>
