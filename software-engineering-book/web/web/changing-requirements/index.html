
<!DOCTYPE html>
<html lang="en-GB"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Web section – Software Engineering 10th edition</title><link rel="dns-prefetch" href="//s0.wp.com"><link rel="dns-prefetch" href="//secure.gravatar.com"><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//s.w.org"><link rel="stylesheet" id="wp-block-library-css" href="https://c0.wp.com/c/5.2.4/wp-includes/css/dist/block-library/style.min.css" type="text/css" media="all"><link rel="stylesheet" id="chld_thm_cfg_parent-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/style.css" type="text/css" media="all"><link rel="stylesheet" id="freedom_style-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom-child1/style.css" type="text/css" media="all"><link rel="stylesheet" id="freedom_googlefonts-css" href="http://fonts.googleapis.com/css?family=Fira+Sans%7CVollkorn&ver=5.2.4" type="text/css" media="all"><link rel="stylesheet" id="freedom-fontawesome-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/fontawesome/css/font-awesome.css" type="text/css" media="all"><link rel="stylesheet" id="easy_table_style-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/plugins/easy-table/themes/default/style.css" type="text/css" media="all"><link rel="stylesheet" id="chld_thm_cfg_separate-css" href="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom-child1/ctc-style.css" type="text/css" media="all"><link rel="stylesheet" id="jetpack_css-css" href="https://c0.wp.com/p/jetpack/7.8/css/jetpack.css" type="text/css" media="all"><script type="text/javascript" src="https://c0.wp.com/c/5.2.4/wp-includes/js/jquery/jquery.js"></script><script type="text/javascript" src="https://c0.wp.com/c/5.2.4/wp-includes/js/jquery/jquery-migrate.min.js"></script><script type="text/javascript" src="https://iansommerville.com/software-engineering-book/static/wp-content/themes/freedom/js/freedom-custom.js"></script><link rel="dns-prefetch" href="//v0.wordpress.com"><link rel="dns-prefetch" href="//c0.wp.com"><style type="text/css">img#wpstats{display:none}</style><style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style><style type="text/css">
				/* If html does not have either class, do not show lazy loaded images. */
				html:not( .jetpack-lazy-images-js-enabled ):not( .js ) .jetpack-lazy-image {
					display: none;
				}
			</style><script>
				document.documentElement.classList.add(
					'jetpack-lazy-images-js-enabled'
				);
			</script><meta property="og:type" content="article"><meta property="og:title" content="Web section"><meta property="og:url" content="https://iansommerville.com/software-engineering-book/static/web/archpatterns/event-driven-control/"><meta property="og:description" content="In centralized control models, control decisions are usually determined by the values of some system state variables. By contrast, Web section models are driven by externally generated eve…"><meta property="article:published_time" content="2014-10-07T13:01:04+00:00"><meta property="article:modified_time" content="2019-02-07T09:11:52+00:00"><meta property="og:site_name" content="Software Engineering 10th edition"><meta property="og:image" content="https://s0.wp.com/i/blank.jpg"><meta property="og:locale" content="en_GB"><meta name="twitter:text:title" content="Web section"><meta name="twitter:card" content="summary"><style type="text/css" id="wp-custom-css">
				img.myimg {
	display: block;
  margin-left: auto;
  margin-right: auto; 
	margin-top: 35px;
	padding: 5px;
	border-style: solid;
	border-width: 1px;
	border-color: black;
}
img.horiz {
	width: 680px;
}

img.vert {
	height: 680px;
}

figcaption.mycap {
  margin-left: 150px;
  margin-right: 150px; 
	font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif; 
	font-size: 19px;
	color: #808080;   /* Mid grey */
	font-weight: normal;
	text-align: center;
	margin-top: 20px;
	margin-bottom: 40px;
	padding-bottom: 10px;
	border-bottom: 1px solid #000000;  /* black */
}

figcaption.noborder {
	margin-bottom: 0px;
	border-bottom: 0px solid #000000;  /* black */
}

figcaption.nospace{
	margin-top: 0px
}

figcaption.para {
	text-align:justify;
}			</style></head><body class="page-template-default page page-id-697 page-child parent-pageid-282 no-sidebar-full-width wide">
<div id="page" class="hfeed site">
		<header id="masthead" class="site-header clearfix"><div id="header-text-nav-container" class="clearfix">
			<div class="inner-wrap">
				<div id="header-text-nav-wrap" class="clearfix">
					<div id="header-left-section">
												<div id="header-text" class="">
															<h3 id="site-title">
									<a href="https://iansommerville.com/software-engineering-book/static/" title="Software Engineering 10th edition" rel="home">Software Engineering 10th edition</a>
								</h3>
															<p id="site-description">Web sections</p>
													</div>
					</div>
			</div>

	</div>

		
	</header><div id="main" class="clearfix">
		<div class="inner-wrap clearfix">


	<div id="primary">
		<div id="content" class="clearfix">
			
			<article id="post-255" class="post-255 page type-page status-publish hentry"><header class="entry-header"><h1 class="entry-title">
				Enduring and volatile requirements			</h1>
			</header><div class="entry-content clearfix">
		<p>Requirements change during the RE process and after a system has gone into service is inevitable. Developing software requirements focuses attention on software capabilities, business objectives and other business systems. As the requirements are elicited and analysed, you normally develop a better understanding of users’ needs. This feeds information back to the user who may then propose a change to the requirements. Furthermore, it may take several years to specify and develop a large system. Over that time, the system’s environment and the business objectives change and the requirements evolve to reflect this.</p>
<p>From an evolution perspective, requirements fall into two classes:</p>
<p><strong>Enduring requirements</strong> These are relatively stable requirements that derive from the core activity of the organisation and which relate directly to the domain of the system. For example, in a hospital there will always be requirements concerned with patients, doctors, nurses, treatments, etc. These requirements may be derived from domain models that show the entities and relations which characterise an application domain (Prieto-Díaz and Arango, 1991, Easterbrook, 1993).</p>
<p><strong>Volatile requirements</strong> These are requirements that are likely to change during the system development process or after the system has been become operational. Examples of volatile requirements are requirements resulting from government health-care policies or healthcare charging mechanisms.</p>
<p>Harker and others (Harker et al., 1993) suggested that volatile requirements fall into five classes. Using these as a base, I have developed the classification shown in the following table:</p>
<div class="table-responsive"><table style="width:100%; " class="easy-table easy-table-default " border="0"><thead><tr><th>Requirement type</th>
<th> Description</th>
</tr></thead><tbody><tr><td>Mutable requirements</td>
<td>Requirements that change because of changes to the environment in which the organisation is operating. For example in hospital systems the funding of patient care may change and thus require different treatment information to be collected.</td>
<td></td>
</tr><tr><td>Emergent requirements</td>
<td>Requirements that emerge as the customer's understanding of the system develops during the system development. The design process may reveal new emergent requirements.</td>
<td></td>
</tr><tr><td>Consequential requirements</td>
<td>Requirements that result from the introduction of the computer system. Introducing the computer system may change the organisations processes and open up new ways of working which generate new system requirements.</td>
<td></td>
</tr><tr><td>Compatibility requirements</td>
<td>Requirements that depend on the particular systems or business processes within an organisation. As these change the compatibility requirements on the commissioned or delivered system may also have to evolve.</td>
<td></td>
</tr></tbody></table></div>
<h4>References</h4>
<p>Prieto-DÌaz, R. and Arango, G. (1991). <em>Domain Analysis and Software System Modeling</em>. Los Alamitos CA.: IEEE Press.</p>
<p>Easterbrook, S. (1993). “Domain Modelling with Hierarchies of Alternative Viewpoints”. <em>Proc. RE ’93</em>, San Diego, USA.</p>
<p>Harker, S. D. P., Easton, K. D., et al. (1993). “The Change and Evolution of Requirements as a Challenge to the Practice of Software Engineering”. <em>Proc. RE ’93</em>, San Diego, USA.</p>
			</div>

	</article>
				<footer id="colophon" class="clearfix"><div class="footer-socket-wrapper clearfix">
				<div class="inner-wrap">
					<div class="footer-socket-area">
						<div class="copyright">Copyright © 2019&nbsp<a href="https://iansommerville.com/software-engineering-book/static/" title="Software Engineering 10th edition"><span>Software Engineering 10th edition</span></a>. </div>					</div>
				</div>
			</div>
		</footer><a href="#masthead" id="scroll-up"><i class="fa fa-chevron-up"></i></a>
	</div>
		<div style="display:none">
	</div>
